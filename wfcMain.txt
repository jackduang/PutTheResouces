using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;
using TMPro;
using System.Linq;

//先观察熵的最小值，再对其进行坍缩

namespace MyWfcTest { 
public enum Dir
{
    Left = 0, Down =1, Up =2 , Right =3
}
public class ModelRulesInfor
{
    public Dictionary<Dir, List<TileBase>> Dic_DirTiles;
    public ModelRulesInfor()
    {
        Dic_DirTiles = new Dictionary<Dir, List<TileBase>>();
        for (int i = 0; i < 4; i++)
        {
            Dic_DirTiles.Add((Dir)i, new List<TileBase>());
        }
    }
}

public class Model
{
    public Vector3Int pos;

    public bool IsCollapse = false;
    public TileBase[] CurTiles;
    public int Entropy = 0;

    Main main;
    // Dictionary<TileBase, ModelRulesInfor> alltilesRules;
    public Model(Vector3Int pos)
    {
        //alltilesRules = AllTilesRules;

        main = Main.instance;
        CurTiles = new TileBase[main.TileInfor.Keys.Count];
        this.pos = pos;
        int index = 0;
        foreach (var item in main.TileInfor.Keys)
        {

            CurTiles[index] = item;
            index++;
        }
    }

    public void FindMinEntropy(Vector3Int[] RoundPos)
    {
        List<Model> models = new List<Model>();
        for (int i = 0; i < RoundPos.Length; i++)
        {
            Vector3Int curpos = RoundPos[i];
            Model RoundModle = main.Models[curpos];
            models.Add(RoundModle);
            foreach (var item in RoundModle.CurTiles)
            {
                if (item != null)
                    RoundModle.Entropy++;

            }
            
        }

        //得到熵最小的
        models.Sort((a,b) =>
        {
          return  a.Entropy.CompareTo(b.Entropy);

        });
        if (models[0].Entropy == 0)
        {
            models.RemoveAt(0);
        }
        models[0].CollapseRoundTiles();
    }

    //坍缩周围格子
    public void CollapseRoundTiles()
    {
        if (CurTiles == null||CurTiles.Length <= 0)
        {
            Debug.Log("当前格子瓷砖为空");
            return;
        }
        Vector3Int[] RoundPos = main.GetRoundPos(pos);
        
        for (int j = 0; j < RoundPos.Length; j++)
        {
            Vector3Int curPos = RoundPos[j];
            if (!main.Models.ContainsKey(curPos))
                continue;
            TileBase[] RoundGirdCurTiles = main.Models[curPos].CurTiles;
            HashSet<TileBase> dirTiles = new HashSet<TileBase>();
            foreach (var item in CurTiles)
            {
                //获取Tile规则表
                if (item == null)
                {
                    continue;
                }
                List<TileBase> dirtileTemp = main.TileInfor[item].Dic_DirTiles[(Dir)j];

                foreach (var item2 in dirtileTemp)
                {
                    dirTiles.Add(item2);
                }



            }
            Debug.Log("GridAllTilesCount::" + dirTiles.Count);
            for (int i = 0; i < RoundGirdCurTiles.Length; i++)
            {
                TileBase item2 = RoundGirdCurTiles[i];
                if (dirTiles.Contains(item2))
                {
                    continue;
                }
                else
                {
                    RoundGirdCurTiles[i] = null;
                }
            }
            dirTiles.Clear();
            int notNullIndex = 0;
            foreach (var item in RoundGirdCurTiles)
            {
                if (item != null)
                    notNullIndex++;

            }
            main.GetMapText(curPos, Color.red, notNullIndex.ToString());
            FindMinEntropy(RoundPos);
        }
       
    }
}

public class Main : MonoBehaviour
{
    // Start is called before the first frame update
    public GameObject text;
    public Grid grid;
    public BoundsInt bounds;
    public Tilemap tilemap;
    public Dictionary<TileBase, ModelRulesInfor> TileInfor = new Dictionary<TileBase, ModelRulesInfor>();
    public Dictionary<Vector3Int, Model> Models = new Dictionary<Vector3Int, Model>();

    public static Main instance;

    private void Awake()
    {
        instance = this;

    }
    void Start()
    {
        InitTilesInfor();
    }

    void InitTilesInfor()
    {
        InitModeRules();

        InitMode();
    }
     void InitMode()
    {
        for (int x = bounds.xMin; x < bounds.xMax; x++)
        {
            for (int y = bounds.yMin; y < bounds.yMax; y++)
            {
                Vector3Int pos = new Vector3Int(x, y, 0);
                Models.Add(pos, new Model(pos));
            }
        }

    }

    //初始化瓷砖邻居规则信息
     void InitModeRules()
    {
        for (int x = bounds.xMin; x < bounds.xMax; x++)
        {
            for (int y = bounds.yMin; y < bounds.yMax; y++)
            {
                Vector3Int pos = new Vector3Int(x, y, 0);
                Vector3 CellPos = tilemap.CellToWorld(pos);
                GameObject TMP_textOBJ = Instantiate(text, CellPos, Quaternion.identity, transform.Find("Canvas/texts"));
                TMP_textOBJ.name = pos.ToString();
                TMP_textOBJ.GetComponent<TMP_Text>().text = pos.ToString();
                if (!tilemap.HasTile(pos))
                {
                    continue;
                }
                TileBase tile = tilemap.GetTile(pos);
                if (!TileInfor.ContainsKey(tile))
                {
                    TileInfor.Add(tile, new ModelRulesInfor());
                }
                GetRoundTile(tile, pos);


            }
        }


    }

     void GetRoundTile(TileBase ForTile, Vector3Int pos)
    {
        Vector3Int[] RoundPos = GetRoundPos(pos);
        for (int i = 0; i < RoundPos.Length; i++)
        {
            Vector3Int curPos = RoundPos[i];
            if (!tilemap.HasTile(curPos))
                continue;
            TileBase tile = tilemap.GetTile(curPos);
            if (!TileInfor.ContainsKey(tile))
                TileInfor.Add(tile, new ModelRulesInfor());

            List<TileBase> List_dirTiles = TileInfor[ForTile].Dic_DirTiles[(Dir)i];
            if (List_dirTiles.Contains(tile))
            {
                continue;
            }
            List_dirTiles.Add(tile);
        }
    }
    // Update is called once per frame
    void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            Vector3 mousepos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            Vector3Int CellPos = tilemap.WorldToCell(mousepos);
            if (!Models.ContainsKey(CellPos))
            {
                print("no");
                return;
            }
            // Debug.Log( Models[CellPos].CurTiles.Count);
            for (int i = 0; i < Models[CellPos].CurTiles.Length; i++)
            {
                if (i < Models[CellPos].CurTiles.Length - 1)
                {
                    Models[CellPos].CurTiles[i] = null;
                }

            }
            // Debug.Log(tilemap.GetTile(CellPos));

            Models[CellPos].CollapseRoundTiles();



        }
    }

    public Vector3Int[] GetRoundPos(Vector3Int pos)
    {
        Vector3Int[] Roundpos = new Vector3Int[4];
        int index = 0;
        for (int x = pos.x - 1; x <= pos.x + 1; x++)
        {
            for (int y = pos.y - 1; y <= pos.y + 1; y++)
            {
                Vector3Int curPos = new Vector3Int(x, y, pos.z);
                if ((x != pos.x && y != pos.y) || (curPos == pos))
                {
                    continue;
                }
                Roundpos[index] = curPos;
                index++;
            }

        }
        return Roundpos;
    }

    public void GetMapText(Vector3Int pos ,Color color,string text)
    {
        TextMeshProUGUI textUGUI = GameObject.Find(pos.ToString()).GetComponent<TextMeshProUGUI>();
        textUGUI.color = color;
        textUGUI.text = text;
    }
    private void OnDrawGizmos()
    {
        bounds.position = new Vector3Int(Mathf.RoundToInt(transform.position.x), Mathf.RoundToInt((int)transform.position.y), Mathf.RoundToInt((int)transform.position.z));
        foreach (var item in bounds.allPositionsWithin)
        {
            Gizmos.DrawWireCube(item, new Vector3Int(1, 1, 1));
        }
    }
}
}
